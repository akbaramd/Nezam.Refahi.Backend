# Entity Framework Core Configurations

This document explains the Entity Framework Core configurations for the Nezam.Refahi.Backend project.

## Schema Organization

The project uses **database schemas** to organize tables by bounded context:

### 1. **`identity` Schema** - Identity Bounded Context
- **`Users`** - User accounts and authentication
- **`UserTokens`** - JWT and refresh tokens
- **`RefreshSessions`** - User session management
- **`OtpChallenges`** - OTP verification challenges

### 2. **`settings` Schema** - Settings Bounded Context
- **`SettingsSections`** - Main settings sections
- **`SettingsCategories`** - Settings categories within sections
- **`SystemSettings`** - Individual system settings
- **`SettingChangeEvents`** - Audit trail for setting changes

### 3. **`shared` Schema** - Shared Kernel
- **`Provinces`** - Geographic provinces/states
- **`Cities`** - Cities within provinces

## Configuration Files

### Identity Configurations

#### `UserConfiguration.cs`
- **Table**: `Users` in `identity` schema
- **Key Features**:
  - Value objects: `PhoneNumber`, `NationalId`, `DeviceFingerprint`
  - Unique constraints on phone and national ID
  - Comprehensive indexing for performance
  - Audit fields from base aggregate root

#### `UserTokensConfiguration.cs`
- **Table**: `UserTokens` in `identity` schema
- **Key Features**:
  - Token validation and expiration
  - Device tracking and IP address logging
  - Optimized indexes for token lookup
  - SQL Server specific optimizations

#### `RefreshSessionConfiguration.cs`
- **Table**: `RefreshSessions` in `identity` schema
- **Key Features**:
  - Session rotation and revocation
  - Device fingerprinting
  - Token hash management with salt

#### `OtpChallengeConfiguration.cs`
- **Table**: `OtpChallenges` in `identity` schema
- **Key Features**:
  - OTP hash and nonce management
  - Rate limiting and attempt tracking
  - Phone number validation
  - Client identification

### Settings Configurations

#### `SettingsSectionConfiguration.cs`
- **Table**: `SettingsSections` in `settings` schema
- **Key Features**:
  - Hierarchical organization of settings
  - Display order management
  - Active/inactive status tracking

#### `SettingsCategoryConfiguration.cs`
- **Table**: `SettingsCategories` in `settings` schema
- **Key Features**:
  - Categories within sections
  - Unique names per section
  - Cascade deletion with sections

#### `SystemSettingConfiguration.cs`
- **Table**: `SystemSettings` in `settings` schema
- **Key Features**:
  - Value objects: `SettingKey`, `SettingValue`
  - Type-safe setting values
  - Read-only and active status
  - Audit trail support

#### `SettingChangeEventConfiguration.cs`
- **Table**: `SettingChangeEvents` in `settings` schema
- **Key Features**:
  - Complete audit trail
  - Old and new value tracking
  - User change tracking
  - Performance optimized indexes

### Shared Configurations

#### `ProvinceConfiguration.cs`
- **Table**: `Provinces` in `shared` schema
- **Key Features**:
  - Geographic province management
  - Unique province codes
  - One-to-many relationship with cities

#### `CityConfiguration.cs`
- **Table**: `Cities` in `shared` schema
- **Key Features**:
  - City management within provinces
  - Postal code support
  - Unique city names per province

## Key Design Principles

### 1. **Value Objects**
- Use `OwnsOne` for value objects
- Proper indexing on value object properties
- Validation at the domain level

### 2. **Indexing Strategy**
- **Unique constraints** where business rules require
- **Composite indexes** for common query patterns
- **Filtered indexes** for nullable fields
- **Performance indexes** for frequently queried fields

### 3. **Relationship Management**
- **Cascade delete** for dependent entities
- **Proper foreign key constraints**
- **Navigation property configuration**

### 4. **Audit Trail**
- **CreatedAt/ModifiedAt** timestamps
- **CreatedBy/ModifiedBy** user tracking
- **Change event logging** for critical entities

## Database Schema Benefits

### 1. **Organization**
- Clear separation of concerns
- Easy to identify table ownership
- Simplified backup and maintenance

### 2. **Security**
- Schema-level permissions
- Granular access control
- Audit trail isolation

### 3. **Performance**
- Optimized indexes per context
- Reduced index fragmentation
- Better query plan optimization

### 4. **Maintainability**
- Clear table grouping
- Easier schema migrations
- Simplified troubleshooting

## Migration Notes

### 1. **Schema Creation**
```sql
-- Create schemas if they don't exist
CREATE SCHEMA IF NOT EXISTS identity;
CREATE SCHEMA IF NOT EXISTS settings;
CREATE SCHEMA IF NOT EXISTS shared;
```

### 2. **Cross-Schema References**
- Foreign keys can reference tables in different schemas
- Ensure proper schema qualification in queries
- Consider performance implications of cross-schema joins

### 3. **Index Naming**
- Index names are auto-generated by EF Core
- Consider custom naming for production databases
- Monitor index fragmentation and maintenance

## Best Practices

### 1. **Configuration Consistency**
- Follow the established pattern for new configurations
- Use appropriate schema names
- Maintain consistent naming conventions

### 2. **Performance Optimization**
- Create indexes based on actual query patterns
- Monitor query performance in production
- Regular index maintenance and optimization

### 3. **Data Integrity**
- Use appropriate constraints and validations
- Implement proper cascade delete rules
- Maintain referential integrity across schemas

### 4. **Documentation**
- Keep configurations well-documented
- Update this README when adding new configurations
- Document any schema-specific considerations
