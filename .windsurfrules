You are designing a business logic component within a Domain-Driven Design (DDD) architecture, using EF Core as the ORM layer.

Given the following rules, decide whether the logic should be placed inside an Entity or a Domain Service:

1. If the logic:
   - Directly belongs to one Entity
   - Operates on that Entity’s state
   - Requires access only to the Entity’s internal invariants
   Then: implement it **as a method inside the Entity**

2. If the logic:
   - Involves coordination across multiple Entities or Aggregates
   - Does not naturally belong to a single Entity
   - Is a pure business rule that doesn’t involve infrastructure concerns
   - Is stateless (no internal state persisted between calls)
   Then: implement it as a **Domain Service**

Also:
- Domain Services should expose intention-revealing methods, e.g. `CanUserBookTour(...)`, `CalculateReservationCost(...)`, `IsEligibleForDiscount(...)`
- Domain Services should NOT manage persistence, workflows, orchestration, or side-effects like sending emails — these belong to Application Services.

In addition:

3. **Check the Bounded Context**:
   - Identify whether the logic belongs to a specific **Bounded Context**
   - If no context is defined yet, define it explicitly based on the domain language and use-case boundaries
   - Ensure that models and services are not shared across unrelated contexts

4. **EF Core Compatibility**:
   - Ensure that the model design is EF Core–friendly (e.g., navigation properties, aggregate root boundaries, shadow properties, value object embedding)
   - Maintain separation between domain logic and persistence logic (no EF-specific code in Entities or Domain Services)
   - Design Aggregates and Entities so they can be easily persisted and tracked via EF Core

Finally:
- Think like a DDD expert.
- Recommend the appropriate DDD building block (Entity, Value Object, Aggregate Root, Domain Service, Repository, Application Service, Factory)
- Ensure proper separation of concerns and encapsulation
- Emphasize clarity, maintainability, testability, and long-term scalability
